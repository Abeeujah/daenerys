/// # Privacy-Preserving Therapy Payment Contract
///
/// Enables patients to pay therapists anonymously using zero-knowledge proofs.
/// Patient identities remain hidden on-chain while therapists can verifiably
/// claim payments.
///
/// ## Architecture
/// - Integrates with Garaga's UltraHonk verifier for ZK proof verification
/// - Uses cryptographic nullifiers to prevent double-claiming
/// - Transfers ERC20 tokens (ETH/STRK) for actual payments
///
/// ## Security Model
/// - Commitments hide patient identity while binding to payment details
/// - Nullifiers are unique per payment, preventing replay attacks
/// - ZK proofs ensure only authorized parties can claim funds

use starknet::ContractAddress;

/// Interface for the Garaga-generated UltraHonk verifier contract.
/// Verifies zero-knowledge proofs generated by the Noir circuit.
#[starknet::interface]
pub trait IUltraKeccakZKHonkVerifier<TContractState> {
    /// Verifies a ZK proof and returns public outputs on success.
    ///
    /// # Arguments
    /// * `full_proof_with_hints` - Serialized proof with verification hints
    ///
    /// # Returns
    /// * `Ok(public_outputs)` - Array of public values from the circuit
    /// * `Err(error)` - Verification failure reason
    fn verify_ultra_keccak_zk_honk_proof(
        self: @TContractState, full_proof_with_hints: Span<felt252>,
    ) -> Result<Span<u256>, felt252>;
}

/// Standard ERC20 interface for token transfers
#[starknet::interface]
pub trait IERC20<TContractState> {
    fn transfer(ref self: TContractState, recipient: ContractAddress, amount: u256) -> bool;
    fn transfer_from(
        ref self: TContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256,
    ) -> bool;
    fn balance_of(self: @TContractState, account: ContractAddress) -> u256;
}

/// Public interface for the therapy payment contract.
#[starknet::interface]
pub trait ITherapyPayment<TContractState> {
    /// Registers a payment commitment from a patient and transfers tokens.
    ///
    /// # Arguments
    /// * `commitment` - Hash binding patient secret to therapist and amount
    /// * `amount` - Payment amount in token units
    ///
    /// # Note
    /// Caller must approve this contract to spend `amount` tokens first.
    fn deposit(ref self: TContractState, commitment: felt252, amount: u256);

    /// Claims a payment using a zero-knowledge proof.
    ///
    /// # Arguments
    /// * `commitment` - The payment commitment to claim
    /// * `nullifier_hash` - Unique identifier preventing double-claims
    /// * `full_proof_with_hints` - ZK proof of knowledge of the preimage
    ///
    /// # Panics
    /// * If nullifier was already used
    /// * If deposit doesn't exist
    /// * If proof verification fails
    fn withdraw(
        ref self: TContractState,
        commitment: felt252,
        nullifier_hash: felt252,
        full_proof_with_hints: Span<felt252>,
    );

    /// Returns deposit info for a commitment.
    fn get_deposit(self: @TContractState, commitment: felt252) -> (ContractAddress, u256);

    /// Checks if a nullifier has been used.
    fn is_nullifier_used(self: @TContractState, nullifier_hash: felt252) -> bool;

    /// Returns the verifier contract address.
    fn get_verifier_address(self: @TContractState) -> ContractAddress;

    /// Returns the token contract address.
    fn get_token_address(self: @TContractState) -> ContractAddress;
}

#[starknet::contract]
pub mod TherapyPayment {
    use starknet::storage::{
        StoragePointerReadAccess, StoragePointerWriteAccess, Map, StorageMapReadAccess,
        StorageMapWriteAccess,
    };
    use starknet::{ContractAddress, get_caller_address, get_contract_address};
    use super::{
        IUltraKeccakZKHonkVerifierDispatcher, IUltraKeccakZKHonkVerifierDispatcherTrait,
        IERC20Dispatcher, IERC20DispatcherTrait,
    };

    #[storage]
    struct Storage {
        /// Address of the Garaga verifier contract
        verifier_address: ContractAddress,
        /// Address of the ERC20 token used for payments (ETH or STRK)
        token_address: ContractAddress,
        /// Maps commitment -> (depositor, amount)
        deposits: Map<felt252, (ContractAddress, u256)>,
        /// Tracks used nullifiers to prevent double-claiming
        nullifiers: Map<felt252, bool>,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        Deposited: Deposited,
        Withdrawn: Withdrawn,
    }

    /// Emitted when a patient deposits funds.
    #[derive(Drop, starknet::Event)]
    pub struct Deposited {
        #[key]
        pub commitment: felt252,
        pub depositor: ContractAddress,
        pub amount: u256,
    }

    /// Emitted when a therapist claims a payment.
    #[derive(Drop, starknet::Event)]
    pub struct Withdrawn {
        #[key]
        pub commitment: felt252,
        #[key]
        pub therapist: ContractAddress,
        pub amount: u256,
        pub nullifier_hash: felt252,
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        verifier_address: ContractAddress,
        token_address: ContractAddress,
    ) {
        self.verifier_address.write(verifier_address);
        self.token_address.write(token_address);
    }

    #[abi(embed_v0)]
    impl TherapyPaymentImpl of super::ITherapyPayment<ContractState> {
        fn deposit(ref self: ContractState, commitment: felt252, amount: u256) {
            let caller = get_caller_address();
            let this_contract = get_contract_address();

            let (_, existing_amount) = self.deposits.read(commitment);
            assert(existing_amount == 0, 'Commitment already exists');

            // Transfer tokens from caller to this contract
            let token = IERC20Dispatcher { contract_address: self.token_address.read() };
            let success = token.transfer_from(caller, this_contract, amount);
            assert(success, 'Token transfer failed');

            self.deposits.write(commitment, (caller, amount));
            self.emit(Deposited { commitment, depositor: caller, amount });
        }

        fn withdraw(
            ref self: ContractState,
            commitment: felt252,
            nullifier_hash: felt252,
            full_proof_with_hints: Span<felt252>,
        ) {
            let caller = get_caller_address();

            assert(!self.nullifiers.read(nullifier_hash), 'Nullifier already used');

            let (_, amount) = self.deposits.read(commitment);
            assert(amount > 0, 'Deposit not found');

            let verifier = IUltraKeccakZKHonkVerifierDispatcher {
                contract_address: self.verifier_address.read(),
            };

            let result = verifier.verify_ultra_keccak_zk_honk_proof(full_proof_with_hints);

            match result {
                Result::Ok(_) => {
                    self.nullifiers.write(nullifier_hash, true);

                    // Transfer tokens from this contract to the therapist
                    let token = IERC20Dispatcher { contract_address: self.token_address.read() };
                    let success = token.transfer(caller, amount);
                    assert(success, 'Token transfer failed');

                    let zero_address: ContractAddress = 0.try_into().unwrap();
                    self.deposits.write(commitment, (zero_address, 0));

                    self.emit(Withdrawn { commitment, therapist: caller, amount, nullifier_hash });
                },
                Result::Err(_) => { panic!("Invalid proof"); },
            }
        }

        fn get_deposit(self: @ContractState, commitment: felt252) -> (ContractAddress, u256) {
            self.deposits.read(commitment)
        }

        fn is_nullifier_used(self: @ContractState, nullifier_hash: felt252) -> bool {
            self.nullifiers.read(nullifier_hash)
        }

        fn get_verifier_address(self: @ContractState) -> ContractAddress {
            self.verifier_address.read()
        }

        fn get_token_address(self: @ContractState) -> ContractAddress {
            self.token_address.read()
        }
    }
}
