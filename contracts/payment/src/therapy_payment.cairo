/// # Privacy-Preserving Therapy Payment Contract
///
/// Enables patients to pay therapists anonymously using zero-knowledge proofs.
/// Patient identities remain hidden on-chain while therapists can verifiably
/// claim payments.
///
/// ## Architecture
/// - Integrates with Garaga's UltraHonk verifier for ZK proof verification
/// - Uses cryptographic nullifiers to prevent double-claiming
/// - Stores balances per therapist for withdrawal
///
/// ## Security Model
/// - Commitments hide patient identity while binding to payment details
/// - Nullifiers are unique per payment, preventing replay attacks
/// - ZK proofs ensure only authorized parties can claim funds

use starknet::ContractAddress;

/// Interface for the Garaga-generated UltraHonk verifier contract.
/// Verifies zero-knowledge proofs generated by the Noir circuit.
#[starknet::interface]
pub trait IUltraKeccakZKHonkVerifier<TContractState> {
    /// Verifies a ZK proof and returns public outputs on success.
    ///
    /// # Arguments
    /// * `full_proof_with_hints` - Serialized proof with verification hints
    ///
    /// # Returns
    /// * `Ok(public_outputs)` - Array of public values from the circuit
    /// * `Err(error)` - Verification failure reason
    fn verify_ultra_keccak_zk_honk_proof(
        self: @TContractState, full_proof_with_hints: Span<felt252>,
    ) -> Result<Span<u256>, felt252>;
}

/// Public interface for the therapy payment contract.
#[starknet::interface]
pub trait ITherapyPayment<TContractState> {
    /// Registers a payment commitment from a patient.
    ///
    /// # Arguments
    /// * `commitment` - Hash binding patient secret to therapist and amount
    /// * `amount` - Payment amount in wei
    fn deposit(ref self: TContractState, commitment: felt252, amount: u256);

    /// Claims a payment using a zero-knowledge proof.
    ///
    /// # Arguments
    /// * `commitment` - The payment commitment to claim
    /// * `nullifier_hash` - Unique identifier preventing double-claims
    /// * `full_proof_with_hints` - ZK proof of knowledge of the preimage
    ///
    /// # Panics
    /// * If nullifier was already used
    /// * If deposit doesn't exist
    /// * If proof verification fails
    fn withdraw(
        ref self: TContractState,
        commitment: felt252,
        nullifier_hash: felt252,
        full_proof_with_hints: Span<felt252>,
    );

    /// Returns deposit info for a commitment.
    fn get_deposit(self: @TContractState, commitment: felt252) -> (ContractAddress, u256);

    /// Checks if a nullifier has been used.
    fn is_nullifier_used(self: @TContractState, nullifier_hash: felt252) -> bool;

    /// Returns accumulated balance for a therapist.
    fn get_therapist_balance(self: @TContractState, therapist: ContractAddress) -> u256;

    /// Returns the verifier contract address.
    fn get_verifier_address(self: @TContractState) -> ContractAddress;
}

#[starknet::contract]
pub mod TherapyPayment {
    use starknet::storage::{
        StoragePointerReadAccess, StoragePointerWriteAccess, Map, StorageMapReadAccess,
        StorageMapWriteAccess,
    };
    use starknet::{ContractAddress, get_caller_address};
    use super::{IUltraKeccakZKHonkVerifierDispatcher, IUltraKeccakZKHonkVerifierDispatcherTrait};

    #[storage]
    struct Storage {
        /// Address of the Garaga verifier contract
        verifier_address: ContractAddress,
        /// Maps commitment -> (depositor, amount)
        deposits: Map<felt252, (ContractAddress, u256)>,
        /// Tracks used nullifiers to prevent double-claiming
        nullifiers: Map<felt252, bool>,
        /// Accumulated balances per therapist
        therapist_balances: Map<ContractAddress, u256>,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        Deposited: Deposited,
        Withdrawn: Withdrawn,
    }

    /// Emitted when a patient deposits funds.
    #[derive(Drop, starknet::Event)]
    pub struct Deposited {
        #[key]
        pub commitment: felt252,
        pub amount: u256,
    }

    /// Emitted when a therapist claims a payment.
    #[derive(Drop, starknet::Event)]
    pub struct Withdrawn {
        #[key]
        pub commitment: felt252,
        #[key]
        pub therapist: ContractAddress,
        pub amount: u256,
        pub nullifier_hash: felt252,
    }

    #[constructor]
    fn constructor(ref self: ContractState, verifier_address: ContractAddress) {
        self.verifier_address.write(verifier_address);
    }

    #[abi(embed_v0)]
    impl TherapyPaymentImpl of super::ITherapyPayment<ContractState> {
        fn deposit(ref self: ContractState, commitment: felt252, amount: u256) {
            let caller = get_caller_address();

            let (_, existing_amount) = self.deposits.read(commitment);
            assert(existing_amount == 0, 'Commitment already exists');

            self.deposits.write(commitment, (caller, amount));
            self.emit(Deposited { commitment, amount });
        }

        fn withdraw(
            ref self: ContractState,
            commitment: felt252,
            nullifier_hash: felt252,
            full_proof_with_hints: Span<felt252>,
        ) {
            let caller = get_caller_address();

            assert(!self.nullifiers.read(nullifier_hash), 'Nullifier already used');

            let (_, amount) = self.deposits.read(commitment);
            assert(amount > 0, 'Deposit not found');

            let verifier = IUltraKeccakZKHonkVerifierDispatcher {
                contract_address: self.verifier_address.read(),
            };

            let result = verifier.verify_ultra_keccak_zk_honk_proof(full_proof_with_hints);

            match result {
                Result::Ok(_) => {
                    self.nullifiers.write(nullifier_hash, true);

                    let current_balance = self.therapist_balances.read(caller);
                    self.therapist_balances.write(caller, current_balance + amount);

                    let zero_address: ContractAddress = 0.try_into().unwrap();
                    self.deposits.write(commitment, (zero_address, 0));

                    self.emit(Withdrawn { commitment, therapist: caller, amount, nullifier_hash });
                },
                Result::Err(_) => { panic!("Invalid proof"); },
            }
        }

        fn get_deposit(self: @ContractState, commitment: felt252) -> (ContractAddress, u256) {
            self.deposits.read(commitment)
        }

        fn is_nullifier_used(self: @ContractState, nullifier_hash: felt252) -> bool {
            self.nullifiers.read(nullifier_hash)
        }

        fn get_therapist_balance(self: @ContractState, therapist: ContractAddress) -> u256 {
            self.therapist_balances.read(therapist)
        }

        fn get_verifier_address(self: @ContractState) -> ContractAddress {
            self.verifier_address.read()
        }
    }
}
